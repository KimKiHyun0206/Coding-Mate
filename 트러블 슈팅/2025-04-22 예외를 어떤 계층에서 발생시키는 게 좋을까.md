# 결론
코드가 조금 더러워져도 향후 문제가 될 수 있는 코드를 작성하는 것은 좋지 않다고 생각하기에 예외를 서비스 계층에서 처리해야겠다.
책임을 제대로 분리하지 않은 코드는 업데이트가 힘들고 유지보수가 힘들어지는 주요 원인이 된다. 처음부터 이러한 규칙을 잘 지켜서 코딩하는 것이 좋을 것 같다.


# 문제 발생 경위
프로젝트 진행 중 엔티티 조회 시 엔티티가 조회되지 않았을 시에 예외를 발생시켜야 하는데 어떤 계층에서 해야 할지 고민이다.

# 문제 원인 분석
현재 코드는 레포지토리에서 예외를 발생시키는데, 애플리케이션 설계 중 클래스간에 책임이 정확하게 분리되지 않아서 이러한 일이 발생하는 것이라고 분석됨.
* 레포지토리 계층은 단순히 데이터베이스에서 데이터를 조회하는 것에만 집중해야함
* 서비스 계층은 비즈니스 로직 및 예외를 발생시켜야할 책임이 있음

이러한 설계를 제대로 지키기 못했기 때문에 이러한 일이 발생했다고 생각함. 그리고 순수 JPA와 Querydsl을 동시에 사용함에 따라 `orElseThrow()`메소드를 사용하지 못하는 메소드도 있어 이러한 일이 발생한다고 생각한다.


# 문제 원인 해결방식
1. 문제의 원인인 예외를 발생시키는 것은 온전히 서비스 계층이 해야하는 일이라고 생각하기에 서비스 계층에게 예외 발생을 위임함
2. 레포지토리 계층에서 `orElseThrow()`를 사용하지 않도록 함. 순전히 JPA만 사용한다면 `orElseThrow()`가 좋을 수도 있지만 Querydsl과 동시에 사용한다면 이 메소드가 일관성을 해칠 수 있음
3. 따로 오브젝트가 null값인지 검사하는 Util을 사용할 필요가 있음.
4. Util을 서비스 계층에서 사용하여 null값을 가지고 있다면 예외를 발생시키면 됨.

# 결론
새로운 Util을 만들어서 오브젝트가 null인지 체크하고 예외 발생인 오직 서비스 계층에만 위임하도록 함